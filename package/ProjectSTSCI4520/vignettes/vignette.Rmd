---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

```{r setup}
library(ProjectSTSCI4520)
```

```{r}
int_data <-
  function(datapoints,
           longitudes,
           latitudes,
           use_elev = F,
           gridpoints) {
    #station data should have one column of data, then the station's longitude and latitude
    #Interpolation done via gpgp
    #train the gpgp model
    coord <- cbind(longitudes, latitudes)
    X <- cbind(1, coord) #add the intercept column
    grid_matrix <- sf::st_coordinates(gridpoints)
    Xpred <- cbind(1, grid_matrix)
    if (use_elev){
      elevations <- elevatr::get_elev_point(data.frame(x = longitudes, y = latitudes), prj = 4326)
      grid_elevations <- elevatr::get_elev_point(gridpoints)
      X <- cbind(X, elevations$elevation)
      Xpred <- cbind(Xpred, grid_elevations$elevation)
    }
    gp_model <- GpGp::fit_model(
      y = datapoints,
      locs = coord,
      X = X,
      covfun_name = "exponential_sphere",
      silent = T
    )
    interpolations <-
      GpGp::predictions(fit = gp_model,
                        locs_pred = grid_matrix,
                        X_pred = Xpred)
    returned <- cbind(interpolations, grid_matrix, gridpoints$inUSA)
    colnames(returned) <-
      c("interpolations", "longitudes", 'latitudes', 'inUSA')
    return(data.frame(returned))
  }
# map of the average temperature of stations in March 2024 vs the interpolated data map
non_contig = c("AK", "HI", "NL", "PE", "NS", "NB", "QC", "ON", "MB", "SK", "AB", "BC", "YT", "NT", "NU")
contig_stations = station_info[!station_info$state %in% non_USA, ]

march_2024_data <- daily_weather |> dplyr:::filter(LST_DATE >= "2024-03-01", LST_DATE < "2024-04-01", !state %in% non_USA) |> dplyr:::group_by(`station name`, LONGITUDE, LATITUDE) |> dplyr:::summarise(avg_temp = mean(T_DAILY_AVG))

colmap <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

maps::map("usa")
points(march_2024_data$LONGITUDE, march_2024_data$LATITUDE, pch = 16, col =  colmap(10)[cut(march_2024_data$avg_temp, 10)])
legend(x = -72, y = 40, title="Temperature",legend= levels(cut(march_2024_data$avg_temp, 10)), col = colmap(10), pch=20, xpd=TRUE)
title("Average Temperature (°C) in March 2024")

grid <- create_grid(resolution_X = 100, resolution_Y=100)
interp_data = int_data(march_2024_data$avg_temp, march_2024_data$LONGITUDE, march_2024_data$LATITUDE, gridpoints = grid, use_elev = T)
plot_interpolations(interp_data)
title("Average Interpolated Temperature (°C) in March 2024")
```



```{r}
num_stations = nrow(contig_stations)
stations_high_day = rep(NA, times = num_stations)
stations_low_day = rep(NA, times = num_stations)

i = 1
for (station_id in contig_stations$WBANNO){
  yearly_estimates = get_yearly_cycle(station_id)
  min_row = which.min(yearly_estimates$avgTemp)
  max_row = which.max(yearly_estimates$avgTemp)
  stations_high_day[i] = yearly_estimates[max_row, "dayofY"]
  stations_low_day[i] = yearly_estimates[min_row, "dayofY"]
  i = i + 1
}

colmap <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

maps::map("usa")
points(contig_stations$LONGITUDE, contig_stations$LATITUDE, pch = 16, col =  colmap(10)[cut(stations_high_day, 10)])
legend(x = -72, y = 40, title="Day of The Year",legend= levels(cut(stations_high_day, 10)), col = colmap(10), pch=20, xpd=TRUE)
title("Warmest Day of the Year")

days_from_jan1 = pmin(stations_low_day, 365 - stations_low_day)
mean(stations_high_day)

maps::map("usa")
points(contig_stations$LONGITUDE, contig_stations$LATITUDE, pch = 16, col =  colmap(10)[cut(days_from_jan1, 10)])
legend(x = -74, y = 40, title="Days From Jan 1st",legend = levels(cut(days_from_jan1, 10)), col = colmap(10), pch=20, xpd=TRUE)
title("Coldest Day of the Year")

high_day_interp_data = interpolate_data(stations_high_day, contig_stations$LONGITUDE, contig_stations$LATITUDE, gridpoints = grid)
plot_interpolations(high_day_interp_data)
title("Interpolated Warmest Day of the Year")

low_day_interp_data = interpolate_data(stations_low_day, contig_stations$LONGITUDE, contig_stations$LATITUDE, gridpoints = grid)
plot_interpolations(low_day_interp_data)
title("Interpolated Coldest Day of the Year")
```

To estimate the warmest and coldest day of the year for each station, we first estimate the yearly temperature cycle for the stations. For each station, we create a ordinary least squares regression based on historical station data which optimizes to predict the daily average temperature for each day of they year using a model with the covariates: sin(2*pi*dayofY/yearlength), cos(2*pi*dayofY/yearlength), sin(4*pi*dayofY/yearlength), cos(4*pi*dayofY/yearlength). These parameters are used to use represent days of the year as a cycle, representing January 1st and December 31st as similar days for weather as an assumption.

The interpolations for the coldest day of the year comes with some problems that should be notes. Since some locations are predicted to have a December coldest day and others are predicted to have a January coldest day, the locations in between them are often predicted to have a coldest day in the summer. This occurs because of incorrect assumptions in our model for creating interpolations. The model is created to have smooth and linear predictions due to the assumtions of the linear model. However, it does not understand that the prediction for day of the year is rather a cyclic.

```{r}
diverse_stations_ids = sort(c(63828, 94060, 4994, 64758, 53152, 94092, 53968, 94645, 54808, 4223))
diverse_stations = station_info[station_info$WBANNO %in% diverse_stations_ids, ]

yearly_cycles = rep(NA, times = 10)

par(mar = c(4, 5, 3, 12), xpd = TRUE)
plot(1, xlab="Day of the Year", ylab="Expected Temperature (°C)", xlim=c(1, 365), ylim=c(-20, 30))
i = 1
for (station_id in diverse_stations$WBANNO){
  yearly_cycle = get_yearly_cycle(station_id)
  points(x = yearly_cycle$dayofY, y = yearly_cycle$avgTemp, type = "l", col = rainbow(10)[i], lwd = 2, lty = i)
  i = i + 1
}
par(cex = 0.8)
legend(x="right", inset = c(-0.5, 0), title="Station", legend = diverse_stations$`station name`, col = rainbow(10), lty = 1:10, pch=20)
```

```{r}
trend_coefs = rep(NA, length = nrow(contig_stations))
standard_errors = rep(NA, length = nrow(contig_stations))
i = 1
for (station_id in contig_stations$WBANNO){
    station_trend = temperature_trend(station_id)
    trend_coefs[i] = station_trend$coefficients["years_elapsed", "Estimate"]
    standard_errors[i] = station_trend$coefficients["years_elapsed", "Std. Error"]
    i = i + 1
}

maps::map("usa")
points(contig_stations$LONGITUDE, contig_stations$LATITUDE, pch = 16, col =  colmap(10)[cut(trend_coefs, 10)])
legend(x = -74, y = 40, title="°C/yr Trend",legend = levels(cut(trend_coefs, 10)), col = colmap(10), pch=20, xpd=TRUE)
title("Temperature Trends in °C per Year")

low_se_indices = order(standard_errors)[1:as.integer(length(standard_errors) * 0.9)]
standard_errors[low_se_indices]

trend_interp_data = interpolate_data(trend_coefs[low_se_indices], contig_stations$LONGITUDE[low_se_indices], contig_stations$LATITUDE[low_se_indices], gridpoints = grid)
plot_interpolations(trend_interp_data)
title("Interpolated Temperature Trends in °C per Year")
```

```{r}

```



